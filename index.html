<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Stadium Lens Simulator (HK Edition)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: white; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; cursor: default; touch-action: none; }
        
        /* Camera Frame Overlay */
        #camera-frame {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
            z-index: 5; 
            pointer-events: none;
            display: none; 
        }

        /* Grid Lines */
        .grid-line { position: absolute; background-color: rgba(255, 255, 255, 0.5); pointer-events: none; }
        .grid-line-v { width: 1px; height: 100%; top: 0; }
        .grid-line-h { height: 1px; width: 100%; left: 0; }

        .ui-layer { position: absolute; z-index: 10; pointer-events: none; }
        .interactive { pointer-events: auto; }

        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; height: 20px; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 24px; width: 24px; border-radius: 50%;
            background: #3b82f6; cursor: pointer; margin-top: -10px; border: 2px solid white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #4b5563; border-radius: 2px; }

        #map-canvas {
            background: rgba(0, 20, 0, 0.8);
            cursor: crosshair;
            touch-action: none;
            display: block;
        }

        select {
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23007CB2%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat; background-position: right 0.7rem top 50%; background-size: 0.65rem auto; appearance: none;
        }
        
        .focal-mark { cursor: pointer; padding: 4px 6px; border-radius: 4px; transition: background 0.2s; user-select: none; width: 30px; text-align: center; }
        .focal-mark:hover { background: rgba(255,255,255,0.2); color: #3b82f6; }
        @media (max-width: 640px) { .focal-mark { font-size: 10px; width: auto; padding: 2px; } }

        .map-minimized #map-content { display: none; }
        .map-minimized { width: auto !important; }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    
    <div id="camera-frame">
        <div class="grid-line grid-line-v" style="left: 33.33%;"></div>
        <div class="grid-line grid-line-v" style="left: 66.66%;"></div>
        <div class="grid-line grid-line-h" style="top: 33.33%;"></div>
        <div class="grid-line grid-line-h" style="top: 66.66%;"></div>
    </div>

    <div class="ui-layer w-full h-full flex flex-col justify-between p-2 md:p-4 pointer-events-none">
        
        <div class="flex flex-col md:flex-row justify-between items-start gap-2 pointer-events-none">
            <div class="bg-black/70 backdrop-blur-md p-3 rounded-lg border border-gray-700 w-full md:max-w-sm interactive shadow-lg">
                <div class="flex justify-between items-center mb-2">
                    <h1 class="text-lg font-bold text-blue-400 leading-none">Stadium Lens</h1>
                    <span class="text-[10px] text-gray-400 bg-gray-800 px-1 rounded">HK EDITION</span>
                </div>
                <div class="mb-2">
                    <select id="venue-select" class="w-full bg-gray-800 border border-gray-600 text-white text-xs rounded p-2 focus:ring-blue-500 focus:border-blue-500 block">
                        <option value="hk_coliseum">Hong Kong Coliseum (Hung Hom)</option>
                        <option value="asia_world">AsiaWorld-Expo (Arena)</option>
                        <option value="kai_tak">Kai Tak Main Stadium</option>
                    </select>
                </div>
                <p class="text-[10px] text-gray-400 leading-tight">Drag Map to move.<br><b>Double-Tap Map</b> (or Shift+Click) to set Target.</p>
            </div>
            
            <div class="bg-black/70 backdrop-blur-md p-3 rounded-lg border border-gray-700 interactive shadow-lg flex flex-row md:flex-col gap-4 md:gap-0 justify-between min-w-[200px]">
                <div>
                    <div class="text-[10px] text-gray-400 uppercase tracking-wider">Target Dist</div>
                    <div class="text-lg font-mono text-white leading-tight"><span id="distance-val">0</span> m</div>
                </div>
                <div class="md:mt-2">
                    <div class="text-[10px] text-gray-400 uppercase tracking-wider">FOV (Diag)</div>
                    <div class="text-lg font-mono text-white leading-tight"><span id="fov-val">0</span>°</div>
                </div>
                <div class="md:mt-2">
                    <div class="text-[10px] text-gray-400 uppercase tracking-wider">Cam Height</div>
                    <div class="text-lg font-mono text-white leading-tight"><span id="height-val">1.7</span> m</div>
                </div>
            </div>
        </div>

        <div class="relative w-full mt-auto md:flex md:flex-row md:items-end md:justify-between md:gap-4">
            
            <div id="map-container" class="interactive relative group absolute bottom-36 left-0 md:static md:order-1 md:bottom-auto md:left-auto flex flex-col items-start transition-all duration-200">
                <div class="flex justify-between items-center bg-black/80 rounded-t px-2 py-1 backdrop-blur border-t border-l border-r border-gray-700 w-full md:w-[220px]">
                    <span class="text-[10px] font-bold text-white">Map</span>
                    <button id="map-toggle-btn" class="text-xs text-blue-400 font-bold px-2 hover:text-white" onclick="toggleMap()">[−]</button>
                </div>
                <div id="map-content" class="border-b border-l border-r border-gray-700 bg-black/80 backdrop-blur rounded-b">
                    <canvas id="map-canvas" width="220" height="220" class="w-[150px] h-[150px] md:w-[220px] md:h-[220px]" title="Drag to move camera. Shift+Click to move target figure."></canvas>
                </div>
            </div>

            <div class="interactive bg-black/90 backdrop-blur-md p-4 border-t border-gray-700 shadow-2xl 
                        absolute -bottom-2 -left-2 -right-2 w-[calc(100%+16px)] rounded-t-xl
                        md:bg-black/80 md:border md:rounded-xl md:static md:w-full md:max-w-xl md:order-2">
                <div class="flex justify-between gap-1 mb-4">
                    <button onclick="setSensor('ff')" id="btn-ff" class="flex-1 py-1.5 text-xs bg-blue-600 rounded hover:bg-blue-500 transition border border-blue-400 font-bold">Full Frame</button>
                    <button onclick="setSensor('apsc')" id="btn-apsc" class="flex-1 py-1.5 text-xs bg-gray-700 rounded hover:bg-gray-600 transition border border-gray-600">APS-C</button>
                    <button onclick="setSensor('mft')" id="btn-mft" class="flex-1 py-1.5 text-xs bg-gray-700 rounded hover:bg-gray-600 transition border border-gray-600">M4/3</button>
                </div>

                <div class="mb-1 flex justify-between items-end">
                    <label class="text-xs font-bold text-gray-300">Focal Length</label>
                    <span class="text-xl font-bold text-blue-400"><span id="focal-val">14</span>mm</span>
                </div>
                <input type="range" id="focal-slider" min="0" max="9" step="0.05" value="0" class="w-full mb-3 touch-pan-y">
                
                <div class="flex justify-between text-[10px] text-gray-500 font-mono w-full px-0.5 select-none">
                    <span class="focal-mark" onclick="setFocalIndex(0)">14</span>
                    <span class="focal-mark" onclick="setFocalIndex(1)">24</span>
                    <span class="focal-mark" onclick="setFocalIndex(2)">35</span>
                    <span class="focal-mark" onclick="setFocalIndex(3)">50</span>
                    <span class="focal-mark" onclick="setFocalIndex(4)">85</span>
                    <span class="focal-mark" onclick="setFocalIndex(5)">135</span>
                    <span class="focal-mark" onclick="setFocalIndex(6)">200</span>
                    <span class="focal-mark" onclick="setFocalIndex(7)">400</span>
                    <span class="focal-mark" onclick="setFocalIndex(8)">600</span>
                    <span class="focal-mark" onclick="setFocalIndex(9)">800</span>
                </div>
            </div>

        </div>
    </div>

    <!-- Import Three.js -->
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';

        // --- Configuration & Data ---
        
        const SENSORS = {
            ff: { w: 36, h: 24, name: "Full Frame" },
            apsc: { w: 23.6, h: 15.6, name: "APS-C" },
            mft: { w: 17.3, h: 13, name: "Micro 4/3" }
        };

        const FOCAL_STOPS = [14, 24, 35, 50, 85, 135, 200, 400, 600, 800];

        // --- Boundary Clamping ---
        function clampRect(x, z, xMax, zMax) {
            return { x: Math.max(-xMax, Math.min(xMax, x)), z: Math.max(-zMax, Math.min(zMax, z)) };
        }
        function clampRadius(x, z, radius) {
            const dist = Math.sqrt(x*x + z*z);
            if (dist <= radius) return { x, z };
            const scale = radius / dist;
            return { x: x * scale, z: z * scale };
        }
        function clampEllipse(x, z, xRad, zRad) {
            const dx = x / xRad; const dz = z / zRad;
            const distSq = dx*dx + dz*dz;
            if (distSq <= 1) return { x, z };
            const dist = Math.sqrt(distSq);
            return { x: x/dist, z: z/dist };
        }

        // Updated Scales based on user feedback (Kai Tak 1.4x larger)
        const VENUES = {
            hk_coliseum: {
                name: "HK Coliseum",
                mapScale: 2.2,
                build: buildHKColiseum,
                drawMap: drawHKColiseumMap,
                getHeight: getHKColiseumHeight,
                clamp: (x, z) => clampRadius(x, z, 48)
            },
            asia_world: {
                name: "AsiaWorld-Expo",
                mapScale: 1.5,
                build: buildAsiaWorld,
                drawMap: drawAsiaWorldMap,
                getHeight: getAsiaWorldHeight,
                clamp: (x, z) => clampRect(x, z, 43, 63)
            },
            kai_tak: {
                name: "Kai Tak Main Stadium",
                // Upscaled stadium -> Downscale map (zoom out) to fit
                // Prev Scale 1.1 -> New Scale 0.8
                mapScale: 0.8,
                build: buildKaiTak,
                drawMap: drawKaiTakMap,
                getHeight: getKaiTakHeight,
                clamp: (x, z) => clampEllipse(x, z, 115, 140) // Wider boundary
            }
        };

        let currentVenue = VENUES.hk_coliseum;
        let currentSensor = SENSORS.ff;
        let currentFocalLength = 14; 
        let cameraHeight = 1.7; 
        let camX = 0; let camZ = -50;
        let lookTarget = new THREE.Vector3(0, 1.7, 0); 
        let targetGroup = null; 

        // --- Three.js Init ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 500);

        const camera = new THREE.PerspectiveCamera(46, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        let stadiumGroup = new THREE.Group();
        scene.add(stadiumGroup);

        const raycaster = new THREE.Raycaster();

        // --- Height Logic ---
        function getHKColiseumHeight(x, z) {
            const dist = Math.sqrt(x*x + z*z);
            if (dist < 22) return 1.7; 
            const t = (dist - 22) / (45 - 22);
            return 1.7 + (Math.max(0, t) * 40);
        }
        
        function getAsiaWorldHeight(x, z) {
            const w = 43; const l = 63; 
            if (Math.abs(x) < 30 && z < 50 && z > -50) return 1.7;
            let dist = 0;
            if (Math.abs(x) >= 30) dist = Math.abs(x) - 30;
            if (z >= 50) dist = Math.max(dist, z - 50);
            return 1.7 + (dist * 0.8);
        }
        
        function getKaiTakHeight(x, z) {
            // Upscaled dimensions logic
            const xRad = 62; const zRad = 90;
            const val = (x*x)/(xRad*xRad) + (z*z)/(zRad*zRad);
            if (val < 1) return 1.7; 
            const distFactor = Math.sqrt(val) - 1; 
            return 1.7 + distFactor * 60; 
        }

        // --- Geometry Builders ---
        function clearStadium() {
            scene.remove(stadiumGroup);
            stadiumGroup = new THREE.Group();
            scene.add(stadiumGroup);
            
            if (targetGroup) {
                stadiumGroup.add(targetGroup);
            } else {
                lookTarget.set(0, 1.7, 0);
            }

            if (currentVenue.name === "HK Coliseum" || currentVenue.name === "AsiaWorld-Expo") {
                scene.background = new THREE.Color(0x050505); 
                scene.fog = new THREE.Fog(0x050505, 30, 400);
                ambientLight.intensity = 0.9; 
                dirLight.intensity = 1.0;     
            } else {
                scene.background = new THREE.Color(0x87CEEB); 
                scene.fog = new THREE.Fog(0x87CEEB, 20, 1000);
                ambientLight.intensity = 0.6;
                dirLight.intensity = 0.8;
            }
        }

        function createTargetFigure(x, z) {
            if (targetGroup) {
                stadiumGroup.remove(targetGroup);
            }
            targetGroup = new THREE.Group();
            
            const mat = new THREE.MeshStandardMaterial({color: 0xffff00, emissive: 0x222200});
            const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.3, 1), mat);
            body.position.y = 0.9; body.castShadow = true;
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshStandardMaterial({color:0xffccaa}));
            head.position.y = 1.7;
            targetGroup.add(body, head);
            
            const rayOrigin = new THREE.Vector3(x, 100, z);
            const rayDir = new THREE.Vector3(0, -1, 0);
            raycaster.set(rayOrigin, rayDir);
            
            const intersects = raycaster.intersectObjects(stadiumGroup.children, true);
            let groundY = 0;
            const validHit = intersects.find(hit => !hit.object.userData.ignoreRaycast);
            if (validHit) {
                groundY = validHit.point.y;
            } else {
                groundY = Math.max(0, currentVenue.getHeight(x, z) - 1.7);
            }

            targetGroup.position.set(x, groundY, z);
            
            const arrowGeo = new THREE.ConeGeometry(0.2, 0.5, 8);
            const arrowMat = new THREE.MeshBasicMaterial({color: 0xffff00});
            const arrow = new THREE.Mesh(arrowGeo, arrowMat);
            arrow.rotation.z = Math.PI;
            arrow.position.y = 2.5;
            targetGroup.add(arrow);

            stadiumGroup.add(targetGroup);
            lookTarget.set(x, groundY + 1.7, z); 
        }

        function buildSteppedSection(width, numRows, rowDepth, rowHeight, startDist, startHeight, color) {
            const sectionGroup = new THREE.Group();
            const seatMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.8, side: THREE.DoubleSide });
            for (let i = 0; i < numRows; i++) {
                const rowGeo = new THREE.BoxGeometry(width, rowHeight, rowDepth);
                const rowMesh = new THREE.Mesh(rowGeo, seatMat);
                const yPos = startHeight + (i * rowHeight) + (rowHeight / 2);
                const zPos = startDist + (i * rowDepth) + (rowDepth / 2);
                rowMesh.position.set(0, yPos, zPos);
                rowMesh.receiveShadow = true;
                sectionGroup.add(rowMesh);
            }
            return sectionGroup;
        }

        function buildHKColiseum() {
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(40, 40), new THREE.MeshStandardMaterial({ color: 0x222222 }));
            floor.rotation.x = -Math.PI/2; stadiumGroup.add(floor);
            const stage = new THREE.Mesh(new THREE.BoxGeometry(14, 1.5, 14), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            stage.position.y = 0.75; stadiumGroup.add(stage);
            
            const numRows = 60; 
            const rowDepth = 0.8; 
            const rowHeight = 0.65; 
            const startDist = 22; 
            const bankW = 35;

            const configs = [{c:0xdd2222, r:0}, {c:0x2244dd, r:Math.PI/2}, {c:0xdddd22, r:Math.PI}, {c:0x22aa22, r:-Math.PI/2}];
            configs.forEach(cf => {
                const s = buildSteppedSection(bankW, numRows, rowDepth, rowHeight, startDist, 0, cf.c);
                s.rotation.y = cf.r; stadiumGroup.add(s);
            });
            for(let i=0; i<4; i++){
                const s = buildSteppedSection(20, numRows, rowDepth, rowHeight, startDist*1.35, 0, 0x555555);
                s.rotation.y = (Math.PI/2)*i + Math.PI/4; stadiumGroup.add(s);
            }
            
            const truss = new THREE.Mesh(new THREE.BoxGeometry(90, 1, 90), new THREE.MeshBasicMaterial({color:0x111111, wireframe:true}));
            truss.position.y = 23; 
            truss.userData = { ignoreRaycast: true };
            stadiumGroup.add(truss);
        }

        function buildAsiaWorld() {
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(86, 127), new THREE.MeshStandardMaterial({ color: 0x333333 }));
            floor.rotation.x = -Math.PI/2; stadiumGroup.add(floor);
            
            const stage = new THREE.Mesh(new THREE.BoxGeometry(24, 1.5, 16), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            stage.position.set(0, 0.75, -50); stadiumGroup.add(stage);

            const seatColor = 0x6a0dad; const blockMat = new THREE.MeshStandardMaterial({ color: seatColor });
            function createFloorBlock(x, z) {
                const b = new THREE.Mesh(new THREE.BoxGeometry(16, 0.2, 20), blockMat);
                b.position.set(x, 0.1, z); stadiumGroup.add(b);
            }
            [[-15,-20],[15,-20],[-15,5],[15,5],[-15,30],[15,30]].forEach(p=>createFloorBlock(p[0],p[1]));

            const rs = buildSteppedSection(100, 30, 0.8, 0.4, 30, 0, seatColor); rs.rotation.y=-Math.PI/2; stadiumGroup.add(rs);
            const ls = buildSteppedSection(100, 30, 0.8, 0.4, 30, 0, seatColor); ls.rotation.y=Math.PI/2; stadiumGroup.add(ls);
            const rear = buildSteppedSection(80, 30, 0.8, 0.4, 50, 0, seatColor); rear.rotation.y=Math.PI; stadiumGroup.add(rear);
            
            const truss = new THREE.Mesh(new THREE.PlaneGeometry(86, 127, 10, 15), new THREE.MeshBasicMaterial({ color: 0x222222, wireframe: true }));
            truss.rotation.x = Math.PI/2; truss.position.y = 19; 
            truss.userData = { ignoreRaycast: true };
            stadiumGroup.add(truss);
        }

        function buildKaiTak() {
            // Upscaled dimensions (1.4x factor)
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(120, 160), new THREE.MeshStandardMaterial({ color: 0x333333 }));
            floor.rotation.x = -Math.PI/2; stadiumGroup.add(floor);

            const baseGeo = new THREE.PlaneGeometry(180, 220);
            const baseMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.rotation.x = -Math.PI/2; base.position.y = -0.1;
            stadiumGroup.add(base);

            const cPurple = 0x6a0dad; const cRed = 0xdd2222; 
            // New wider distances
            const xDist = 62; 
            const zDist = 90;

            const sStand = buildSteppedSection(120, 60, 0.8, 0.55, zDist, 0, cPurple);
            sStand.rotation.y = Math.PI; stadiumGroup.add(sStand);

            const wLower = buildSteppedSection(170, 20, 0.8, 0.4, xDist, 0, cPurple);
            wLower.rotation.y = -Math.PI/2; stadiumGroup.add(wLower);
            const wUpper = buildSteppedSection(170, 35, 0.8, 0.6, xDist + (20*0.8)+3, (20*0.4)+3, cRed);
            wUpper.rotation.y = -Math.PI/2; stadiumGroup.add(wUpper);

            const eLower = buildSteppedSection(170, 20, 0.8, 0.4, xDist, 0, cPurple);
            eLower.rotation.y = Math.PI/2; stadiumGroup.add(eLower);
            const eUpper = buildSteppedSection(170, 35, 0.8, 0.6, xDist + (20*0.8)+3, (20*0.4)+3, cRed);
            eUpper.rotation.y = Math.PI/2; stadiumGroup.add(eUpper);

            const stageMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const stage = new THREE.Mesh(new THREE.BoxGeometry(50, 2, 25), stageMat);
            stage.position.set(0, 1, -zDist + 10);
            stadiumGroup.add(stage);
            const catwalk = new THREE.Mesh(new THREE.BoxGeometry(10, 2, 40), stageMat);
            catwalk.position.set(0, 1, -zDist + 40);
            stadiumGroup.add(catwalk);

            const trussGeo = new THREE.BoxGeometry(220, 6, 8);
            const trussMat = new THREE.MeshStandardMaterial({color: 0xffffff});
            const t1 = new THREE.Mesh(trussGeo, trussMat); t1.position.set(0, 80, -25); 
            t1.userData = { ignoreRaycast: true };
            stadiumGroup.add(t1);
            const t2 = new THREE.Mesh(trussGeo, trussMat); t2.position.set(0, 80, 25); 
            t2.userData = { ignoreRaycast: true };
            stadiumGroup.add(t2);
        }

        const mapCanvas = document.getElementById('map-canvas');
        const ctx = mapCanvas.getContext('2d');
        
        function drawHKColiseumMap(ctx, cx, cy, s) {
            ctx.fillStyle = "#111"; ctx.fillRect(cx - 7*s, cy - 7*s, 14*s, 14*s);
            ctx.fillStyle = "white"; ctx.font="9px sans-serif"; ctx.textAlign="center"; ctx.fillText("STAGE", cx, cy + 3);
            function drawBank(color, angle, dist) {
                ctx.save(); ctx.translate(cx, cy); ctx.rotate(angle);
                ctx.beginPath(); ctx.moveTo(-15*s, -dist*s); ctx.lineTo(15*s, -dist*s);
                ctx.lineTo(25*s, -(dist+20)*s); ctx.lineTo(-25*s, -(dist+20)*s);
                ctx.closePath(); ctx.fillStyle = color; ctx.fill(); ctx.restore();
            }
            const d = 11; 
            drawBank("#dd2222", 0, d); drawBank("#dddd22", Math.PI, d);
            drawBank("#2244dd", Math.PI/2, d); drawBank("#22aa22", -Math.PI/2, d);
            function drawCorner(angle) {
                ctx.save(); ctx.translate(cx, cy); ctx.rotate(angle);
                ctx.beginPath(); ctx.moveTo(-7*s, -20*s); ctx.lineTo(7*s, -20*s);
                ctx.lineTo(10*s, -35*s); ctx.lineTo(-10*s, -35*s);
                ctx.closePath(); ctx.fillStyle = "#666"; ctx.fill(); ctx.restore();
            }
            [Math.PI/4, 3*Math.PI/4, -Math.PI/4, -3*Math.PI/4].forEach(a => drawCorner(a));
        }

        function drawAsiaWorldMap(ctx, cx, cy, s) {
            const seatColor = "#6a0dad"; const blockColor = "#552a6a";
            ctx.fillStyle = "#111"; ctx.fillRect(cx - 12*s, cy - 45*s, 24*s, 8*s);
            ctx.fillStyle = "white"; ctx.font="9px sans-serif"; ctx.textAlign="center"; ctx.fillText("STAGE", cx, cy - 40*s);
            const bw = 16*s; const bl = 20*s; ctx.fillStyle = blockColor;
            [[-15,-20],[15,-20],[-15,5],[15,5],[-15,30],[15,30]].forEach(p => {
                let x = (p[0]<0)?cx-bw-2*s : cx+2*s; ctx.fillRect(x, cy+p[1]*s, bw, bl);
            });
            ctx.fillStyle = seatColor;
            ctx.fillRect(cx - 43*s, cy - 40*s, 13*s, 90*s);
            ctx.fillRect(cx + 30*s, cy - 40*s, 13*s, 90*s);
            ctx.fillRect(cx - 43*s, cy + 45*s, 86*s, 13*s);
        }

        function drawKaiTakMap(ctx, cx, cy, s) {
            // Updated scaled drawing
            ctx.fillStyle = "#333"; ctx.fillRect(cx - 45*s, cy - 65*s, 90*s, 130*s);
            ctx.fillStyle = "#8a2be2"; ctx.beginPath(); ctx.moveTo(cx - 45*s, cy + 65*s);
            ctx.lineTo(cx + 45*s, cy + 65*s); ctx.lineTo(cx + 60*s, cy + 110*s); ctx.lineTo(cx - 60*s, cy + 110*s); ctx.fill();
            ctx.fillStyle = "white"; ctx.font="10px sans-serif"; ctx.textAlign="center"; ctx.fillText("SOUTH", cx, cy + 85*s);
            ctx.fillStyle = "#000";
            ctx.fillRect(cx - 25*s, cy - 80*s, 50*s, 12*s);
            ctx.fillRect(cx - 5*s, cy - 68*s, 10*s, 25*s);
            ctx.fillStyle = "white"; ctx.fillText("STAGE", cx, cy - 75*s);
            ctx.fillStyle = "#2244dd"; ctx.beginPath(); ctx.moveTo(cx - 45*s, cy - 65*s); ctx.lineTo(cx - 45*s, cy + 65*s); ctx.lineTo(cx - 90*s, cy + 80*s); ctx.lineTo(cx - 90*s, cy - 80*s); ctx.fill();
            ctx.save(); ctx.translate(cx-70*s, cy); ctx.rotate(-Math.PI/2); ctx.fillStyle="white"; ctx.fillText("WEST", 0,0); ctx.restore();
            ctx.fillStyle = "#dd4422"; ctx.beginPath(); ctx.moveTo(cx + 45*s, cy - 65*s); ctx.lineTo(cx + 45*s, cy + 65*s); ctx.lineTo(cx + 90*s, cy + 80*s); ctx.lineTo(cx + 90*s, cy - 80*s); ctx.fill();
            ctx.save(); ctx.translate(cx+70*s, cy); ctx.rotate(Math.PI/2); ctx.fillStyle="white"; ctx.fillText("EAST", 0,0); ctx.restore();
        }

        function drawMap() {
            const w = mapCanvas.width; const h = mapCanvas.height;
            const cx = w/2; const cy = h/2; const s = currentVenue.mapScale;
            ctx.clearRect(0,0,w,h); ctx.fillStyle="#111"; ctx.fillRect(0,0,w,h);
            currentVenue.drawMap(ctx, cx, cy, s);
            
            const mapCamX = cx + (camX*s); const mapCamY = cy + (camZ*s);
            const lookMapX = cx + (lookTarget.x * s);
            const lookMapY = cy + (lookTarget.z * s);
            
            ctx.beginPath(); ctx.moveTo(mapCamX, mapCamY); ctx.lineTo(lookMapX, lookMapY);
            ctx.strokeStyle="rgba(255,255,255,0.3)"; ctx.setLineDash([2,2]); ctx.stroke(); ctx.setLineDash([]);
            
            ctx.beginPath(); ctx.arc(mapCamX, mapCamY, 5, 0, Math.PI*2);
            ctx.fillStyle="#3b82f6"; ctx.fill(); ctx.stroke();
            
            if (targetGroup) {
                ctx.beginPath(); ctx.arc(lookMapX, lookMapY, 3, 0, Math.PI*2);
                ctx.fillStyle="#ffff00"; ctx.fill(); 
            }
        }

        const slider = document.getElementById('focal-slider');
        const focalDisplay = document.getElementById('focal-val');
        const fovDisplay = document.getElementById('fov-val');
        const distDisplay = document.getElementById('distance-val');
        const heightDisplay = document.getElementById('height-val');
        const venueSelect = document.getElementById('venue-select');
        const cameraFrame = document.getElementById('camera-frame');

        window.setFocalIndex = function(idx) {
            slider.value = idx;
            updateCamera();
        };

        function updateCamera() {
            const t = parseFloat(slider.value);
            const i = Math.floor(t);
            const f = t - i;
            let val;
            if (i >= FOCAL_STOPS.length - 1) {
                val = FOCAL_STOPS[FOCAL_STOPS.length - 1];
            } else {
                val = FOCAL_STOPS[i] + (FOCAL_STOPS[i+1] - FOCAL_STOPS[i]) * f;
            }
            currentFocalLength = Math.round(val);
            focalDisplay.innerText = currentFocalLength;
            
            const diag = Math.sqrt(currentSensor.w**2 + currentSensor.h**2);
            const dFOV = 2*Math.atan(diag/(2*currentFocalLength))*(180/Math.PI);
            const vFOV = 2*Math.atan(currentSensor.h/(2*currentFocalLength))*(180/Math.PI);
            
            camera.fov = vFOV; camera.updateProjectionMatrix();
            fovDisplay.innerText = dFOV.toFixed(1);

            cameraHeight = currentVenue.getHeight(camX, camZ);
            heightDisplay.innerText = cameraHeight.toFixed(1);
            camera.position.set(camX, cameraHeight, camZ);
            
            camera.lookAt(lookTarget);
            distDisplay.innerText = camera.position.distanceTo(lookTarget).toFixed(1);
            
            if(targetGroup) {
                targetGroup.lookAt(camera.position.x, targetGroup.position.y, camera.position.z);
            }
            
            renderer.render(scene, camera);
        }

        // Calculates and updates the camera frame overlay
        function updateFrame() {
            const screenW = window.innerWidth;
            const screenH = window.innerHeight;
            
            // For vertical orientation, we swap sensor width and height
            const sensorW_eff = currentSensor.h;
            const sensorH_eff = currentSensor.w;

            // Calculate scale factor to fit within the screen
            const scale = Math.min(screenW / sensorW_eff, screenH / sensorH_eff);

            const frameW = sensorW_eff * scale;
            const frameH = sensorH_eff * scale;

            cameraFrame.style.width = `${frameW}px`;
            cameraFrame.style.height = `${frameH}px`;
            cameraFrame.style.display = 'block';
        }

        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (evt.clientX - rect.left) / rect.width * canvas.width,
                y: (evt.clientY - rect.top) / rect.height * canvas.height
            };
        }

        let lastTap = 0;
        mapCanvas.addEventListener('mousedown', (e) => {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTap;
            let isDoubleTap = (tapLength < 300) && (tapLength > 0);
            
            const pos = getMousePos(mapCanvas, e);
            const w = mapCanvas.width; const h = mapCanvas.height;
            const s = currentVenue.mapScale;
            const nx = (pos.x - w/2) / s; 
            const nz = (pos.y - h/2) / s;

            if (e.shiftKey || isDoubleTap) {
                e.preventDefault(); 
                createTargetFigure(nx, nz);
                updateCamera();
                drawMap();
                lastTap = 0; 
                return;
            }
            lastTap = currentTime;
            isDragging = true; 
            updatePosFromMapInternal(nx, nz);
        });

        mapCanvas.addEventListener('dblclick', (e) => {
             const pos = getMousePos(mapCanvas, e);
             const w = mapCanvas.width; const h = mapCanvas.height; const s = currentVenue.mapScale;
             let nx = (pos.x - w/2) / s; 
             let nz = (pos.y - h/2) / s;
             createTargetFigure(nx, nz);
             updateCamera();
             drawMap();
        });

        let isDragging=false;
        function updatePosFromMapInternal(nx, nz) {
            if(currentVenue.clamp) {
                const c = currentVenue.clamp(nx, nz); nx=c.x; nz=c.z;
            }
            camX=nx; camZ=nz;
            drawMap(); updateCamera();
        }

        function updatePosFromMap(e) {
            const pos = getMousePos(mapCanvas, e);
            const w = mapCanvas.width; const h = mapCanvas.height; const s = currentVenue.mapScale;
            let nx = (pos.x - w/2) / s; 
            let nz = (pos.y - h/2) / s;
            updatePosFromMapInternal(nx, nz);
        }
        
        window.addEventListener('mousemove', (e)=>{if(isDragging)updatePosFromMap(e)});
        window.addEventListener('mouseup', ()=>isDragging=false);
        slider.addEventListener('input', updateCamera);
        venueSelect.addEventListener('change', (e)=>{
            currentVenue = VENUES[e.target.value];
            camX=0; camZ=(currentVenue.name.includes("Asia"))?30:-50;
            lookTarget.set(0,1.5,(currentVenue.name.includes("Asia"))?-45:0);
            clearStadium(); currentVenue.build(); drawMap(); updateCamera();
        });
        window.addEventListener('resize', ()=>{
            camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateCamera();
            updateFrame(); // Update frame on resize
        });
        window.setSensor = function(type) {
            currentSensor=SENSORS[type];
            updateCamera();
            updateFrame(); // Update frame on sensor change
        };
        
        ['ff', 'apsc', 'mft'].forEach(t => {
            document.getElementById(`btn-${t}`).addEventListener('click', function() {
                ['ff', 'apsc', 'mft'].forEach(x => {
                    const btn = document.getElementById(`btn-${x}`);
                    if(x === t) {
                        btn.classList.remove('bg-gray-700', 'border-gray-600');
                        btn.classList.add('bg-blue-600', 'border-blue-400', 'font-bold');
                    } else {
                        btn.classList.add('bg-gray-700', 'border-gray-600');
                        btn.classList.remove('bg-blue-600', 'border-blue-400', 'font-bold');
                    }
                });
            });
        });

        // Initialize Map Toggle
        window.toggleMap = function() {
            const container = document.getElementById('map-container');
            const btn = document.getElementById('map-toggle-btn');
            isMapCollapsed = !isMapCollapsed;
            if (isMapCollapsed) {
                container.classList.add('map-minimized');
                btn.innerText = "[+]";
            } else {
                container.classList.remove('map-minimized');
                btn.innerText = "[−]";
                drawMap();
            }
        };

        currentVenue.build(); drawMap(); updateCamera(); updateFrame(); // Initial frame update
    </script>
</body>
</html>
